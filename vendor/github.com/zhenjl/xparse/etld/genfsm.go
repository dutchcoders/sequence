// Copyright (c) 2014 Dataence, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build ignore

package main

import (
	"bufio"
	"compress/gzip"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"time"
)

type node struct {
	b byte    // node value
	f bool    // end of string
	s int     // state
	c []*node // children
	m int     // suffix length
	w string  // suffix
}

func inputFile(fname string) (*bufio.Scanner, *os.File) {
	var s *bufio.Scanner

	f, err := os.Open(fname)
	if err != nil {
		log.Fatal(err)
	}

	if strings.HasSuffix(fname, ".gz") {
		gunzip, err := gzip.NewReader(f)
		if err != nil {
			log.Fatal(err)
		}

		s = bufio.NewScanner(gunzip)
	} else {
		s = bufio.NewScanner(f)
	}

	return s, f
}

func outputFile(fname string) *os.File {
	var (
		ofile *os.File = os.Stdin
		err   error
	)

	if fname != "" {
		// Open output file
		ofile, err = os.OpenFile(fname, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0600)
		if err != nil {
			log.Fatal(err)
		}
	}

	return ofile
}

func main() {
	flag.Parse()
	if len(flag.Args()) != 2 {
		log.Fatal("Invalid command. Must be 'etldfsm <infile> <outfile>.'")
	}

	in, ifile := inputFile(flag.Arg(0))
	defer ifile.Close()

	ofile := outputFile(flag.Arg(1))
	defer ofile.Close()

	s := 0 // state
	root := &node{s: s}
	nodes := append(make([]*node, 0, 10), root)

	for in.Scan() {
		ss := in.Text()
		ss = strings.TrimSpace(ss)
		if len(ss) == 0 {
			continue
		}

		if ss[:2] == "//" {
			continue
		}

		cur := root

		// node before last dot
		var nbld *node
		l := len(ss)

		for i := l - 1; i >= 0; i-- {
			b := ss[i]
			found := false
			var n *node

			for _, n = range cur.c {
				if n.b == b {
					found = true
					break
				}
			}

			if !found {
				s++
				n = &node{b: b, s: s, m: l - i}
				cur.c = append(cur.c, n)
				nodes = append(nodes, n)

				// loop
				if b == '*' {
					n.c = append(n.c, n)
				}
			}

			if b == '.' {
				// we want to remember the "node before last dot" because if we hit
				// something like !city.kobe.jp, we can mark the kobe.jp as final.
				nbld = cur
			} else if b == '!' {
				cur.f = true
				cur.m = nbld.m
				cur.w = ss
			}

			cur = n
			if i == 0 {
				//n.m = len(ss)
				n.w = ss
				n.f = true
			}
		}
	}

	fmt.Fprintf(ofile, `// Copyright (c) 2014 Dataence, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is automatically generated by genfsm.go. Please DO NOT modify.
// This file was generated at %s.

package etld

func etldlen(ss string) int {
	var (
		l int = len(ss)	// string length
		m int			// suffix length
		s int			// state
		b byte			// current byte
		pb byte			// previous byte
	)

loop:
	for i := l-1; i >= 0; i-- {
		b = ss[i]
		if i > 0 {
			pb = ss[i-1]
		} else {
			pb = 0
		}

		//fmt.Printf("s=%%d, b=%%c\n", s, b)

		switch s {
`, time.Now())

	for _, n := range nodes {
		if n.b == '*' {
			fmt.Fprintf(ofile, `		case %d:
			s = %d

			if b == '.' { 
				// hit something like "b.c.kobe.jp", should get "c.kobe.jp"
				m = l-i-1
				break loop
				// %s - final
			} else if i == 0 {
				m = l-i
				// %s - final
			}
`, n.s, n.s, n.w)
			continue
		}

		if len(n.c) > 0 {
			fmt.Fprintf(ofile, "\t\tcase %d:\n", n.s)
			fmt.Fprintf(ofile, "\t\t\tswitch b {\n")

			var star *node

			for _, c := range n.c {
				if c.b == '*' {
					star = c
				} else {
					fmt.Fprintf(ofile, "\t\t\tcase '%c':\n", c.b)
					fmt.Fprintf(ofile, "\t\t\t\ts = %d\n", c.s)
					if c.f {
						// in case we hit something like "zblogspot.com.ar", result
						// should be "com.ar" but there's also "blogspot.com.ar", so
						// we need to make sure we are either behind a "." or it's
						// the beginning.
						fmt.Fprintf(ofile, `				if i == 0 || pb == '.' {
					m = %d
					// %s - final
				}
`, c.m, c.w)
					}
				}
			}

			if star != nil {
				fmt.Fprintf(ofile, `			default:
				s = %d

				if i == 0 {
					m = l-i
					// %s - final
				}
			}
`, star.s, star.w)
			} else {
				fmt.Fprintf(ofile, "\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t}\n")
			}
		}
	}

	fmt.Fprintln(ofile, `		default:
			break loop
		}
	}

	//fmt.Println("m =", m, "l =", l)

	if m != l && ss[l-m-1] != '.' {
			return 0
	}
	return m
}`)
}
